from cmstk.base import BaseFile
import numpy as np


class PoscarFile(BaseFile):
    """File wrapper for a VASP POSCAR file.
    
    Notes:
        File specification:
        https://cms.mpi.univie.ac.at/vasp/vasp/POSCAR_file.html
    
    Args:
        filepath (optional) (str): Filepath to a POSCAR file.
    """

    def __init__(self, filepath="POSCAR"):
        super().__init__(filepath)
        self._commment = "Automatically generated by cmstk."
        self._lattice_constant = None
        self._total_volume = None
        self._lattice_vectors = None
        self._n_atoms_per_symbol = None
        self._selective_dynamics = False
        self._coordinate_system = "Cartesian"
        self._positions = None
        self._relaxations = None

    def read(self, path=None):
        """Reads a POSCAR file.
        
        Args:
            path (optional) (str): Filepath to read.

        Returns:
            None
        """
        if path is None:
            path = self.filepath
        with open(path, "r") as f:
            lines = f.readlines()
        self.comment = lines[0].strip()
        constant_or_volume = float(lines[1].strip())
        if constant_or_volume > 0:
            self.lattice_constant = constant_or_volume
        else:
            self.total_volume = constant_or_volume
        lattice_vectors = lines[2:5]
        lattice_vectors = [
            np.fromstring(l, sep=" ") for l in lattice_vectors
        ]
        lattice_vectors = np.array(lattice_vectors)
        self.lattice_vectors = lattice_vectors
        n_atoms_per_symbol = [int(n) for n in lines[5].split()]
        self.n_atoms_per_symbol = tuple(n_atoms_per_symbol)
        if lines[6][0] in ["S", "s"]:
            self.selective_dynamics = True
        else:
            self.selective_dynamics = False
        if self.selective_dynamics:
            coord_sys_index = 7
        else:
            coord_sys_index = 6
        self.coordinate_system = lines[coord_sys_index].strip()
        positions = lines[coord_sys_index+1:]
        positions = [" ".join(p.split()[:3]) for p in positions]
        positions = [
            np.fromstring(p, sep=" ") for p in positions
        ]
        self.positions = np.array(positions)
        if self.selective_dynamics:
            relaxations = lines[coord_sys_index+1:]
            relaxations = [" ".join(r.split()[3:]) for r in relaxations]
            relaxations = [
                np.fromstring(r, sep=" ", dtype=bool) for r in relaxations
            ]
            self.relaxations = relaxations

    def write(self, path=None):
        """Writes a POSCAR file.
        
        Args:
            path (optional) (str): Filepath to read.

        Returns:
            None
        """
        if path is None:
            path = self.filepath
        with open(path, "w") as f:
            f.write("{}\n".format(self.comment))
            if self.lattice_constant is None:
                f.write("{}\n".format(self.total_volume))
            else:
                f.write("{}\n".format(self.lattice_constant))
            for row in self.lattice_vectors:
                row = row.astype(str)
                row = " ".join(row)
                f.write("{}\n".format(row))
            n_atoms_per_symbol = " ".join(map(str, self.n_atoms_per_symbol))
            f.write("{}\n".format(n_atoms_per_symbol))
            if self.selective_dynamics:
                f.write("Selective dynamics\n")
            f.write("{}\n".format(self.coordinate_system))
            for row in self.positions:
                row = row.astype(str)
                row = " ".join(row)
                f.write("{}\n".format(row))

    @property
    def comment(self):
        """(str): Comment line at the top of the file."""
        return self._comment

    @comment.setter
    def comment(self, value):
        if type(value) is not str:
            raise TypeError()
        self._comment = value

    @property
    def lattice_constant(self):
        """(float): Scaling factor for the lattice."""
        return self._lattice_constant

    @lattice_constant.setter
    def lattice_constant(self, value):
        if type(value) not in [float, type(None)]:
            raise TypeError()
        if type(value) is float:
            if value < 0:
                raise ValueError()
        self._lattice_constant = value

    @property
    def total_volume(self):
        """(float): Total volume of the lattice."""
        return self._total_volume

    @total_volume.setter
    def total_volume(self, value):
        if type(value) not in [float, type(None)]:
            raise TypeError()
        if type(value) is float:
            if value > 0:
                raise ValueError()
        self._total_volume = value

    @property
    def lattice_vectors(self):
        """(numpy.ndarray): Vectors defining the edge of the lattice."""
        return self._lattice_vectors

    @lattice_vectors.setter
    def lattice_vectors(self, value):
        if type(value) is not np.ndarray:
            raise TypeError()
        if value.dtype != float:
            raise ValueError()
        self._lattice_vectors = value

    @property
    def n_atoms_per_symbol(self):
        """(tuple of int): Number of atoms of each type."""
        return self._n_atoms_per_symbol

    @n_atoms_per_symbol.setter
    def n_atoms_per_symbol(self, value):
        if type(value) is not tuple:
            raise TypeError()
        for v in value:
            if type(v) is not int:
                raise TypeError()
        self._n_atoms_per_symbol = value
    
    @property
    def selective_dynamics(self):
        """(bool): Selective dynamics flag."""
        return self._selective_dynamics

    @selective_dynamics.setter
    def selective_dynamics(self, value):
        if type(value) is not bool:
            raise TypeError()
        self._selective_dynamics = value

    @property
    def coordinate_system(self):
        """(str): Type of coordinate system positions are represented in."""
        return self._coordinate_system

    @coordinate_system.setter
    def coordinate_system(self, value):
        valid_chars = ["c", "C", "d", "D", "k", "K"]
        if value[0] not in valid_chars:
            raise ValueError()
        self._coordinate_system = value

    @property
    def positions(self):
        """(numpy.ndarray): Coordinates of all atoms in the lattice."""
        return self._positions

    @positions.setter
    def positions(self, value):
        if type(value) is not np.ndarray:
            raise TypeError()
        if value.dtype != float:
            raise ValueError()
        self._positions = value

    @property
    def relaxations(self):
        """(numpy.ndarray): Selective dynamics relaxation options for each 
        atom."""
        return self._relaxations

    @relaxations.setter
    def relaxations(self, value):
        if type(value) not in [np.ndarray, type(None)]:
            raise TypeError()
        if type(value) is np.ndarray:
            if value.dtype != bool:
                raise ValueError()
        self._relaxations = value
